/*
 * Copyright (c) 2013 Ghrum Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <Scheduler/Task.hpp>

using namespace Ghrum;

/////////////////////////////////////////////////////////////////
// {@see Task::Task} ////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
Task::Task(IPlugin * owner, Delegate<void()> callback, size_t period, bool isParallel)
    : owner_(owner), function_(callback), period_(period), parallel_(isParallel),
      repeating_(period > 0), active_(true) {
}

/////////////////////////////////////////////////////////////////
// {@see Task::operator<} ///////////////////////////////////////
/////////////////////////////////////////////////////////////////
bool Task::operator<(const Task & rhs) {
    return (tick_ == rhs.tick_ ? (priority_ < rhs.priority_) : (tick_ > rhs.tick_));
}

/////////////////////////////////////////////////////////////////
// {@see Task::operator()} //////////////////////////////////////
/////////////////////////////////////////////////////////////////
void Task::operator()() {
    function_();
}

/////////////////////////////////////////////////////////////////
// {@see Task::setTickTime} /////////////////////////////////////
/////////////////////////////////////////////////////////////////
void Task::setTickTime(size_t current, bool isDeferred) {
    tick_ = current + period_ + (isDeferred ? (uint16_t)priority_ / 1000L : 0L);
}

/////////////////////////////////////////////////////////////////
// {@see Task::getTickTime} /////////////////////////////////////
/////////////////////////////////////////////////////////////////
size_t Task::getTickTime() {
    return tick_;
}

/////////////////////////////////////////////////////////////////
// {@see Task::getOwner} ////////////////////////////////////////
/////////////////////////////////////////////////////////////////
IPlugin * Task::getOwner() {
    return owner_;
}

/////////////////////////////////////////////////////////////////
// {@see Task::getName} /////////////////////////////////////////
/////////////////////////////////////////////////////////////////
const std::string & Task::getName() const {
    return name_;
}

/////////////////////////////////////////////////////////////////
// {@see Task::setName} /////////////////////////////////////////
/////////////////////////////////////////////////////////////////
void Task::setName(const std::string & name) {
    name_ = name;
}

/////////////////////////////////////////////////////////////////
// {@see Task::setPriority} /////////////////////////////////////
/////////////////////////////////////////////////////////////////
void Task::setPriority(TaskPriority priority) {
    priority_ = priority;
}

/////////////////////////////////////////////////////////////////
// {@see Task::setCancelled} ////////////////////////////////////
/////////////////////////////////////////////////////////////////
void Task::setCancelled() {
    active_ = false;
}

/////////////////////////////////////////////////////////////////
// {@see Task::isAlive} /////////////////////////////////////////
/////////////////////////////////////////////////////////////////
bool Task::isAlive() {
    return active_;
}

/////////////////////////////////////////////////////////////////
// {@see Task::isParallel} //////////////////////////////////////
/////////////////////////////////////////////////////////////////
bool Task::isParallel() {
    return parallel_;
}

/////////////////////////////////////////////////////////////////
// {@see Task::isReapeating} ////////////////////////////////////
/////////////////////////////////////////////////////////////////
bool Task::isReapeating() {
    return repeating_;
}